// --- PASO 1: IMPORTACIONES (TODAS AL PRINCIPIO) ---
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { corsHeaders } from '../_shared/cors.ts'

// --- PASO 2: FUNCIONES AUXILIARES ---

async function getAuthenticatedUser(req: Request) {
  const authHeader = req.headers.get('Authorization')
  if (!authHeader) throw new Error("Falta la cabecera de autorización.")
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '',
    { global: { headers: { Authorization: authHeader } } }
  )
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error("Usuario no autenticado.")
  return { user, supabase }
}

async function getGeminiResponse(userInput: string, incomeSources: string[], budgets: string[]) {
  const primaryApiKey = Deno.env.get('GEMINI_API_KEY')
  const backupApiKey = Deno.env.get('GEMINI_API_KEY_BACKUP')
  let apiKey = primaryApiKey;

  const prompt = `
    Tu tarea es ser un asistente financiero experto. Tu objetivo principal es identificar una de las siguientes intenciones en el texto del usuario: "registrar_transaccion", "crear_presupuesto", "editar_presupuesto", "eliminar_presupuesto".
    Si la intención es "registrar_transaccion", extrae TODAS las transacciones que encuentres en el texto.
    Responde siempre con un único objeto JSON.

    Contexto del Usuario:
    - Fuentes de ingreso conocidas: [${incomeSources.join(', ')}]
    - Presupuestos de Necesidad: [${budgets.join(', ')}]

    Reglas de Extracción:
    1.  Para "registrar_transaccion": El campo "data" debe ser un array de objetos.
    2.  Para ingresos sin fuente explícita, el campo "fuente" debe ser null.
    3.  Para gastos, la "fuente" SIEMPRE debe ser el producto o servicio (ej: "arriendo", "camisa", "helado"). Si no se menciona, "fuente" es null.
    4.  Si un gasto menciona un presupuesto de necesidad (ej: 'arriendo', 'mercado', 'comida', 'gasolina'), la "categoria" es "necesidad".
    5.  Si un gasto es genérico y no se puede determinar (ej: "gasté 5000"), la "categoria" es "ambiguo".
    6.  Si un gasto es claramente personal (ej: "un helado", "una camisa"), la "categoria" es "deseo".

    Formatos de Respuesta JSON:
    - Transacciones: {"intent": "registrar_transaccion", "data": [{"monto": <num>, "fuente": "<fuente|null>", "tipo": "ingreso|gasto>", "categoria": "<ingreso|necesidad|deseo|ambiguo>"}]}
    - Crear Presupuesto: {"intent": "crear_presupuesto", "data": {"nombre": "<nombre>", "monto": <num>}}
    - Editar Presupuesto: {"intent": "editar_presupuesto", "data": {"nombre": "<nombre>", "monto": <num>}}
    - Eliminar Presupuesto: {"intent": "eliminar_presupuesto", "data": {"nombre": "<nombre>"}}
    - Si no entiendes: {"intent": "no_entendido", "data": null}

    Texto a procesar: "${userInput}"
  `
  const body = { contents: [{ parts: [{ text: prompt }] }] }
  let response;
  try {
    let res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
    });
    if ((res.status === 429 || res.status === 503) && backupApiKey) {
      console.warn(`Error con la clave principal (${res.status}). Cambiando a la de respaldo.`);
      apiKey = backupApiKey;
      res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
      });
    }
    if (!res.ok) throw new Error(`Error de la API de Gemini: ${await res.text()}`);
    response = await res.json();
  } catch(e) { throw new Error(`Error en la llamada a Gemini: ${e.message}`); }

  if (!response.candidates || response.candidates.length === 0) return { intent: "no_entendido" };
  const text = response.candidates[0].content.parts[0].text;
  return JSON.parse(text.replace(/```json|```/g, '').trim());
}

// --- PASO 3: FUNCIÓN PRINCIPAL ---

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') return new Response('ok', { headers: corsHeaders });
  
  try {
    const { user_input, context, clarification } = await req.json();
    if (!user_input && !context) throw new Error("Petición vacía.");
    
    const { user, supabase } = await getAuthenticatedUser(req);
    
    // LÓGICA CONVERSACIONAL (PASO 2 O 3 DE UNA CONVERSACIÓN)
    if (context && clarification) {
        if (context.type === 'ingreso') {
            const sourceName = clarification;
            let { data: matchedSource } = await supabase.from('income_sources').select('id, name').eq('user_id', user.id).ilike('name', sourceName).single();
            if (!matchedSource) {
                const { data: newSource } = await supabase.from('income_sources').insert({ name: sourceName, user_id: user.id }).select().single();
                matchedSource = newSource;
            }
            await supabase.from('transactions').insert({ user_id: user.id, amount: context.monto, description: matchedSource.name, type: 'ingreso', category: 'ingreso', source_id: matchedSource.id });
            return new Response(JSON.stringify({ status: 'success', message: `Ingreso de ${matchedSource.name} registrado.` }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        if (context.type === 'gasto') {
            await supabase.from('transactions').insert({ user_id: user.id, amount: context.monto, description: context.fuente, type: 'gasto', category: clarification });
            return new Response(JSON.stringify({ status: 'success', message: `Gasto de '${context.fuente}' registrado como '${clarification}'.` }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        if (context.type === 'gasto_source') {
            const newContext = { ...context, fuente: clarification, type: 'gasto' };
            return new Response(JSON.stringify({ status: 'clarification_needed', type: 'gasto', message: `Entendido, un gasto en '${clarification}'. ¿Cómo lo clasifico?`, options: ['necesidad', 'deseo'], context: newContext }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }});
        }
    }
    
    // LÓGICA PRINCIPAL (PASO 1 DE UNA CONVERSACIÓN)
    const { data: sourcesData } = await supabase.from('income_sources').select('id, name').eq('user_id', user.id);
    const { data: budgetsData } = await supabase.from('budgets').select('id, name').eq('user_id', user.id);
    const sourceNames = sourcesData?.map(s => s.name) || [];
    const budgetNames = budgetsData?.map(b => b.name) || [];

    const aiResponse = await getGeminiResponse(user_input, sourceNames, budgetNames);
    const { intent, data } = aiResponse;

    let message = "No entendí la instrucción. Intenta de nuevo.";

    switch (intent) {
      case 'registrar_transaccion': {
        const transactions = Array.isArray(data) ? data : [data];
        let responses = [];
        for (const trx of transactions) {
          if (trx.tipo === 'ingreso' && !trx.fuente) {
            return new Response(JSON.stringify({ status: 'clarification_needed', type: 'ingreso', message: `Registré un ingreso de ${trx.monto}. ¿De qué plataforma viene?`, options: sourceNames, context: trx }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }});
          }
          if (trx.tipo === 'gasto' && !trx.fuente) {
            return new Response(JSON.stringify({ status: 'clarification_needed', type: 'gasto_source', message: `Registré un gasto de ${trx.monto}. ¿En qué fue?`, context: trx }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }});
          }
          if (trx.tipo === 'gasto' && trx.categoria === 'ambiguo') {
            return new Response(JSON.stringify({ status: 'clarification_needed', type: 'gasto', message: `Registré un gasto de ${trx.monto} en '${trx.fuente}'. ¿Cómo lo clasifico?`, options: ['necesidad', 'deseo'], context: trx }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }});
          }
          
          if (trx.tipo === 'gasto') {
            const { data: fundsData, error: fundsError } = await supabase.rpc('get_dashboard_data');
            if (fundsError) throw new Error("No pude verificar tus fondos actuales.");
            const currentFunds = fundsData[0];
            const fundToCheck = trx.categoria === 'necesidad' ? currentFunds.shared_needs_balance : currentFunds.personal_wishes_balance;
            const fundName = trx.categoria === 'necesidad' ? 'Necesidades' : 'Deseos';
            if (fundToCheck < trx.monto) {
                responses.push(`No se pudo registrar '${trx.fuente}' porque no tienes fondos suficientes en '${fundName}'.`);
                continue; 
            }
          }
            
          let sourceId = null;
          if (trx.tipo === 'ingreso' && trx.fuente) {
              let matchedSource = sourcesData.find(s => s.name.toLowerCase() === trx.fuente.toLowerCase());
              if (!matchedSource) {
                  const { data: newSource } = await supabase.from('income_sources').insert({ name: trx.fuente, user_id: user.id }).select().single();
                  sourcesData.push(newSource);
                  matchedSource = newSource;
              }
              sourceId = matchedSource.id;
          }
          await supabase.from('transactions').insert({ user_id: user.id, amount: trx.monto, description: trx.fuente, type: trx.tipo, category: trx.categoria || 'deseo', source_id: sourceId });
          responses.push(`'${trx.fuente}' (${trx.monto}) registrado.`);
        }
        message = responses.join(' ');
        break;
      }
      case 'crear_presupuesto': {
        const budgetName = data.nombre.toLowerCase();
        const { error } = await supabase.from('budgets').insert({ name: budgetName, amount: data.monto, user_id: user.id });
        if (error?.code === '23505') message = `El presupuesto '${budgetName}' ya existe.`;
        else if (error) throw error;
        else message = `Presupuesto '${budgetName}' creado.`;
        break;
      }
      case 'editar_presupuesto': {
        const budgetName = data.nombre.toLowerCase();
        const { error } = await supabase.from('budgets').update({ amount: data.monto }).eq('name', budgetName).eq('user_id', user.id);
        if (error) throw error;
        message = `Presupuesto '${budgetName}' actualizado.`;
        break;
      }
      case 'eliminar_presupuesto': {
        const budgetName = data.nombre.toLowerCase();
        const { error } = await supabase.from('budgets').delete().eq('name', budgetName).eq('user_id', user.id);
        if (error) throw error;
        message = `Presupuesto '${budgetName}' eliminado.`;
        break;
      }
    }
    
    return new Response(JSON.stringify({ status: 'success', message }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    
  } catch (error) {
    console.error('Error en función:', error);
    return new Response(JSON.stringify({ error: error.message }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 });
  }
});
